Лабораторная работа 2. «Объекты и Классы»
Тип приложения: консольное; язык: c++.
Определение и реализация тестовых классов, и написание программы, иллюстрирующей их использование (код, делающий нечто, и при этом обязательный отладочный вывод в консоль, для контроля того, какие методы вызываются – особенно важен отладочный вывод во всех конструкторах и деструкторах).

Лабораторная работа может включать несколько программ, не стоит пытаться писать все сразу в одну программу и строго последовательно. Например, сначала стоит написать определение и реализацию простого объекта, создать его статически и динамически, проверить вызов атрибутов и методов. Затем определить конструкторы и деструкторы и проверить их работу. Затем научиться определять классы-наследники. Затем научиться перекрывать методы и создавать виртуальные методы и проверить их использование, и так далее. Настоятельно не рекомендуется в качестве методов использовать переопределяемые операции (++, <<, >> и т.д.).
Рекомендуемые объекты для манипуляций: геометрические фигуры (точки, линии, квадраты, круги, эллипсы), математические объекты (вектора, матрицы) и т.д.
Нерекомендуемые объекты для манипуляций (преподаватель плохо разбирается в этой предметной области, да и надоело): Warrior, Weapon, HP, Damage, и т.д.


•	Реализация

методов объектов

реализация методов сразу в определении или после определения

конструкторов, деструкторов


•	Создание и использование (обращение к атрибутам, вызов методов)

статически создаваемых объектов («MyClass obj;»)

динамически создаваемых объектов («MyClass *obj = new MyClass();»)

объектов с помощью различных конструкторов (у каждого создаваемого объекта должны быть: конструктор без параметров, с параметрами, с параметром-объектом того же класса – конструктор копирования)

помещение объектов в переменные различных типов (объяснять, чем отличается MyBase * obj = new MyBase() от MyBase * obj = new MyDeriv())

объектов классов-наследников (проверить и продемонстрировать, какие конструкторы классов при этом вызываются)

композиция объектов: атрибутом одного объекта класса A является указатель на другой объект класса B, создаваемый в конструкторе класса A и уничтожаемый в деструкторе класса A; композируемые классы должны определяться отдельно (не один в другом); при композиции показать, в чем разница, если объект класса А хранит прямо объект класса В или указатель на объект класса В.


•	Уничтожение

статически созданных объектов

динамически созданных объектов

объектов классов-наследников (проверить и продемонстрировать, какие деструкторы классов при этом вызываются)

Лабораторная работа 3. «Хранилище»
Тип приложения: консольное; язык: без ограничений.
Определение и реализация класса хранилища разнообразных объектов (принадлежащих различным классам, имеющим общего предка), и написание программы, иллюстрирующей использование хранилища. Хранилище должно быть максимально универсальным, это не должно быть хранилище фигур, животных или любых других конкретных объектов; вы должны иметь возможность использовать его для хранения любых объектов, которые у вас в будущем могут появиться. Если умеете пользоваться шаблонами (дженериками и т.д.), используйте их; если не умеете – создавайте хранилище указателей на какой-то самый базовый класс, но этот класс должен быть максимально абстрактный.
Предназначение хранилища – хранить объекты, которые в него помещаются. Для создаваемого хранилища вы должны тщательно продумать, как вы будете его использовать для хранения объектов, какие типовые действия вы будете с хранилищем производить.


•	Функции хранилища объектов

добавление объектов

изъятие объектов (с удалением самого объекта и без)

переход по объектам, если это применимо (текущий, предыдущий, последующий, проверка наличия)

получение очередного объекта из хранилища или объекта по индексу

поочередное обращение к каждому объекту хранилища; вызов функций, реализуемых всеми классами объектов хранилища


•	Функции основной программы: код, который в случайном порядке:

создаёт объекты

добавляет в хранилище

использует (для упрощённого вывода)

удаляет из хранилища

Хранилище должно представлять собой объект, создаваемый и используемый в основной программе. Хранилище должно вести себя (снаружи) или как массив, или как список (на выбор студента). Хранилище должно быть организовано внутри или как массив, или как список (на выбор студента). Студент должен понимать отличие двух предыдущих предложений. Основная программа должна демонстрировать использование основных функций хранилища и запускать цикл из 100, 1000 и 10000 случайных действий и подсчитывать время работы. Действия должны случайным образом выбираться из списка: создание и вставка в случайное место хранилища нового объекта, удаление и уничтожение случайного объекта, запуск любого метода у случайного объекта из хранилища.

Хранилище должно позволять добавлять, удалять объекты в случайной последовательности, корректно обрабатывать подсчет текущего количества объектов в хранилище (с учетом возможных «пустых мест» после удаления каких-то объектов) и динамически увеличивать свой размер, если добавляется больше объектов, чем было предусмотрено изначально.


Лабораторная работа 4. Часть 1 из 2: «Круги на форме»
Тип приложения: GUI; язык: без ограничений.

•	Создать простейшее приложение с GUI, содержащее:

определение простейшего класса CCircle с координатами и постоянным радиусом;

хранилище из Л.Р.3 для хранения объектов класса CCircle;

форму с объектом для рисования (например, PaintBox)


•	Реализовать следующее поведение:

при нажатии мышкой на форме создается новый объект CCircle с координатами нажатия и помещается в хранилище;

при событии Paint должны отрисовываться на форме все объекты из хранилища


•	В зависимости от варианта, реализовать следующее поведение с выбором объектов:

при создании объекта он становится единственным выделенным

при нажатии ЛКМ (левой клавиши мыши) на какой-либо объект CCircle на форме, он становится «выделенным» и отрисовывается отлично от других объектов

при нажатии на кнопку Del, все выделенные объекты должны удаляться

при выделении объекта с помощью ЛКМ и удерживаемой клавиши Ctrl, выделенными становятся несколько объектов

При работе над заданием обратите внимание на то, чтобы не нарушать инкапсуляцию объектов. Нельзя запрашивать у объектов их координаты и проверять, попала ли в них мышка – это должен решать сам объект. Нельзя запрашивать у объектов их координаты и рисовать их на форме – рисовать себя на форме должен сам объект, и так далее.


Лабораторная работа 4. Часть 2 из 2: «MVC»
Тип приложения: GUI; язык: без ограничений.

•	Создать простейшее приложение с GUI, содержащее:
o	три целых числа A, B и C со значением в пределах от 0 до 100
o	каждое из чисел должно отображаться и редактироваться в 3 разных компонентах: в textBox, numericUpDown, trackBar (или аналогичных в других языках), при этом редактирование числа в одном поле должно приводить к изменению отображения этого числа во всех других полях
o	первое и третье число могут иметь значение в пределах от 0 до 100
o	второе число всегда должно быть не меньше первого и не больше третьего
o	приложение должно сохранять значения чисел между запусками (запоминать при закрытии и восстанавливать значения при открытии)

•	Разработанное приложение должно быть реализовано в стиле MVC:

хранение трёх чисел должно быть организовано в виде отдельного объекта-модели

все пересчёты и проверки должны выполняться в объекте-модели

изменение A и C должно реализовывать разрешающее поведение (при нарушении ограничений порядка модель сама перестраивается, чтобы их выполнить, введённое пользователем значение A и C сохраняется), 

изменение B должно реализовывать запрещающее поведение (при нарушении ограничений порядка модель откатывает внесённые пользователем изменения).



Лабораторная работа 5. «Жизненный цикл объектов С++ и Виртуальность»
Тип приложения: консольное; язык: c++.
Определение и реализация тестовых классов, и написание программы, иллюстрирующей их использование. Лабораторная работа должна включать несколько программ, по мере изучения соответствующих понятий из лекционного курса, не стоит пытаться писать все сразу в одну программу и строго последовательно.


•	Определения

перекрываемых методов (показать на примере случай, когда вызывается перекрываемый метод, а когда наследуемый)

виртуальных методов, в т.ч. деструкторов (показать на примере, когда вызывается наследуемый виртуальный метод, а когда базовый)


•	Реализация

проверки на принадлежность некоторому классу

безопасного приведения типов (dynamic_cast)  

безопасного приведения типов (вручную) 

•	Передача объектов как параметров в функции и возвращения объектов как результата из функции, контроль их жизненного цикла

Для проверки на принадлежность некоторому классу необходимо реализовать: 

•	базовый виртуальный метод string classname(), перекрыть его в потомках, проверить работу и показать, какие проблемы возникают при его использовании;

•	базовый виртуальный метод bool isA(string classname), перекрыть его в потомках и показать отличие от метода classname.

Продемонстрировать опасное приведение типов и предварительную проверку типа с помощью реализованного метода isA. Продемонстрировать использование стандартных средств языка (dynamic_cast в c++ или аналог на используемом языке).


Для проверки механизма передачи объектов как параметров в функции необходимо написать три функции:

void func1(Base  obj) { ... };
void func2(Base *obj) { ... };
void func3(Base &obj) { ... };

Далее необходимо создать простой класс Base и его потомок Desc и реализовать в каждом из них три конструктора и по одному деструктору (в каждой из трех функций и во всех конструкторах и деструкторе должен быть отладочный вывод в консоль!):

Base() { ... };
Base(Base *obj) { ... };
Base(Base &obj) { ... };
~Base() { ... };

Desc() { ... };
Desc(Desc *obj) { ... };
Desc(Desc &obj) { ... };
~Desc() { ... };

После этого необходимо создавать объекты классов Base и Desc, и передавать их в каждую из трех функций, объясняя при этом, когда и почему вызывается какой конструктор или деструктор. Необходимо уметь объяснять достоинства и недостатки каждого из вариантов.

Для проверки механизма возврата объектов из функции необходимо написать три функции:

Base func1() { ... };
Base* func2() { ... };
Base& func3() { ... };

Затем необходимо помещать результат вызова каждой из этих трёх функций в локальную переменную и объяснять наблюдаемый отладочный вывод (показывающий последовательность создания и удаления объектов). Необходимо уметь объяснять достоинства и недостатки каждого из вариантов, в том числе уметь идентифицировать неправильную работу с памятью.



Лабораторная работа 6. «Визуальный редактор»
Тип приложения: GUI; язык: без ограничений.
На основе Л.Р.4 реализовать простейший визуальный редактор векторных объектов (круг, квадрат, треугольник, отрезок, и т.д.) со следующей функциональностью:

•	Создание графических объектов на экране:

меню, панель инструментов с доступными классами объектов

добавление нового объекта в рабочую область

•	Манипуляции объектами в рабочей области:

выбор объекта для манипулирования (выделяется цветом или рамкой)

изменение цвета, размера, положения

удаление объекта из рабочей области

контроль выхода за рабочую область (при передвижении объект не должен выходить за границы ни одной своей частью)

•	Программные требования:

манипуляции объектами выполняются с помощью клавиатуры, при этом выбор клавиш  управления должен быть как можно ближе к используемым обычно для таких задач в среде Windows

«хорошая» иерархия классов

использование своего хранилища объектов из Л.Р.3

отделение взаимодействия с пользователем от логики работы классов
